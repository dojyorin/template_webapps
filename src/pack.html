<!doctype html>
<html lang="ja">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, height=device-height, minimum-scale=1, maximum-scale=1, initial-scale=1, user-scalable=no">
        <meta name="referrer" content="no-referrer">

        <title></title>
    </head>

    <body>
        <input multiple type="file" id="files">
    </body>

    <script async type="module">
        function packConfigMeta(){
            return {
                count: 2
            };
        }

        function packConfigHeader(){
            return {
                size: 4,
                hash: 64,
                name: 256
            };
        }

        async function wcHashDigest(data){
            return crypto.subtle.digest("SHA-512", data);
        }

        function toHex(data){
            return Array.from(new Uint8Array(data?.buffer ?? data)).map(n => n.toString(16).padStart(2, "0").toUpperCase()).join("");
        }

        function dvSet(n, w){
            const dv = new DataView(new ArrayBuffer(w));
            dv[`setUint${w * 8}`](0, n);
            return dv.buffer;
        }

        function dvGet(b, w){
            return new DataView(b)[`getUint${w * 8}`](0);
        }

        async function packEncode(files){
            if(files.length > ((0x100 ** packConfigMeta().count) - 1) || files.some(({name, data: {byteLength}}) => (byteLength > ((0x100 ** packConfigHeader().size) - 1)) || (name.length > packConfigHeader().name))){
                throw "";
            }

            const archive = new Uint8Array(packConfigMeta().count + (Object.values(packConfigHeader()).reduce((a, b) => a + b, 0) * files.length) + files.reduce((a, {data: {byteLength}}) => a + byteLength, 0));

            archive.set(new Uint8Array(dvSet(files.length, packConfigMeta().count)), 0);

            for(let i = 0, offset = packConfigMeta().count; i < files.length; i++){
                const {name, data} = files?.at(i);

                archive.set(new Uint8Array(dvSet(data.byteLength, packConfigHeader().size)), offset);
                archive.set(new Uint8Array(await wcHashDigest(data)), offset += packConfigHeader().size);
                archive.set(new TextEncoder().encode(name), offset += packConfigHeader().hash);
                archive.set(new Uint8Array(data), offset += packConfigHeader().name);

                offset += data.byteLength;
            }

            return archive.buffer;
        }

        async function packDecode(archive){
            const files = [];

            for(let i = 0, offset = packConfigMeta().count; i < dvGet(archive.slice(0, packConfigMeta().count), packConfigMeta().count); i++){
                const size = dvGet(archive.slice(offset, offset += packConfigHeader().size), packConfigHeader().size);
                const hash = toHex(archive.slice(offset, offset += packConfigHeader().hash));
                const name = new TextDecoder().decode(archive.slice(offset, offset += packConfigHeader().name)).replace(/\0+$/, "");
                const data = archive.slice(offset, offset += size);

                if(hash !== toHex(await wcHashDigest(data))){
                    throw "";
                }

                files.push({name, data});
            }

            return files;
        }

        document.getElementById("files").addEventListener("change", async({target: {files}})=>{
            const encode = await packEncode(await Promise.all(Array.from(files).map(async f => ({name: f.name, data: await f.arrayBuffer()}))));
            const decode = await packDecode(encode);

            console.log(encode);
            console.log(decode);
        });
    </script>
</html>