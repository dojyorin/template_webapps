<!doctype html>
<html lang="ja">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, height=device-height, minimum-scale=1, maximum-scale=1, initial-scale=1, user-scalable=no">
        <meta name="referrer" content="no-referrer">

        <title></title>
    </head>

    <body>
        <input multiple type="file" id="files">
    </body>

    <script async type="module">
        function bufferEqual(source1, source2){
            const dv1 = new DataView(source1?.buffer ?? source1);
            const dv2 = new DataView(source2?.buffer ?? source2);

            return dv1.byteLength !== dv2.byteLength || new Array(dv1.byteLength).fill(null).every((_, i) => dv1.getUint8(i) === dv2.getUint8(i));
        }

        async function wcHashDigest(data){
            return crypto.subtle.digest("SHA-512", data);
        }

        function dvSetQuad(n){
            const dv = new DataView(new ArrayBuffer(4));
            dv.setUint32(0, n);

            return dv.buffer;
        }

        function dvGetQuad(b){
            return new DataView(b).getUint32(0);
        }

        function packConfigHeader(){
            return {
                size: 4,
                hash: 64,
                name: 256
            };
        }

        async function packEncode(files){
            if(files.some(({size, name: {length}}) => size > (0x100 ** packConfigHeader().size) || length > packConfigHeader().name)){
                throw "";
            }

            const archive = new Uint8Array(Object.values(packConfigHeader()).reduce((a, b) => a + b, 0) * files.length + files.reduce((a, {size}) => a + size, 0));

            let offset = 0;
            for(const file of files){
                const data = await file.arrayBuffer();

                archive.set(new Uint8Array(dvSetQuad(file.size)), offset);
                offset += packConfigHeader().size;
                archive.set(new Uint8Array(await wcHashDigest(data)), offset);
                offset += packConfigHeader().hash
                archive.set(new TextEncoder().encode(file.name), offset);
                offset += packConfigHeader().name
                archive.set(new Uint8Array(data), offset);
                offset += file.size;
            }

            return archive.buffer;
        }

        async function packDecode(archive){
            const files = [];

            let offset = 0;
            while(offset < archive.byteLength){
                const size = dvGetQuad(archive.slice(offset, offset += packConfigHeader().size));
                const hash = archive.slice(offset, offset += packConfigHeader().hash);
                const name = new TextDecoder().decode(archive.slice(offset, offset += packConfigHeader().name)).replace(/\0+$/, "");
                const data = archive.slice(offset, offset += size);

                if(!bufferEqual(hash, await wcHashDigest(data))){
                    throw "";
                }

                files.push(new File([data], name));
            }

            return files;
        }

        document.getElementById("files").addEventListener("change", async({target: {files}})=>{
            const encode = await packEncode([...files]);
            const decode = await packDecode(encode);

            console.log(encode);
            console.log(decode);
        });
    </script>
</html>