<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
    </head>

    <body></body>

    <script async type="module">
        function cryptoConfigECDH(){
            return {
                name: "ECDH",
                namedCurve: "P-521"
            };
        }

        function cryptoConfigECDSA(){
            return {
                name: "ECDSA",
                namedCurve: "P-521"
            };
        }

        function cryptoConfigGCM(v){
            return {
                name: "AES-GCM",
                tagLength: 128,
                iv: v
            };
        }

        function cryptoConfigDSA(){
            return {
                name: "ECDSA",
                hash: {
                    name: "SHA-512"
                }
            };
        }

        async function bufferConcat(...buffers){
            return new Blob(buffers).arrayBuffer();
        }

        async function cryptoDigest(data){
            return crypto.subtle.digest("SHA-512", data);
        }

        async function cryptoExportDerive(){
            const {publicKey, privateKey} = await crypto.subtle.generateKey(cryptoConfigECDH(), true, ["deriveKey"]);

            return {
                pub: await crypto.subtle.exportKey("spki", publicKey),
                sec: await crypto.subtle.exportKey("pkcs8", privateKey)
            };
        }

        async function cryptoExportSign(){
            const {publicKey, privateKey} = await crypto.subtle.generateKey(cryptoConfigECDSA(), true, ["sign", "verify"]);

            return {
                pub: await crypto.subtle.exportKey("spki", publicKey),
                sec: await crypto.subtle.exportKey("pkcs8", privateKey)
            };
        }

        async function cryptoDerive(pub, sec){
            const _pub = await crypto.subtle.importKey("spki", pub, cryptoConfigECDH(), false, []);
            const _sec = await crypto.subtle.importKey("pkcs8", sec, cryptoConfigECDH(), false, ["deriveKey"]);

            const algorithm = {
                name: "ECDH",
                public: _pub
            };

            const type = {
                name: "AES-GCM",
                length: 256
            };

            return crypto.subtle.deriveKey(algorithm, _sec, type, false, ["encrypt", "decrypt"]);
        }

        async function cryptoEncrypt(com, data){
            const iv = crypto.getRandomValues(new Uint8Array(12));

            return bufferConcat(iv, await crypto.subtle.encrypt(cryptoConfigGCM(iv), com, data));
        }

        async function cryptoDecrypt(com, data){
            const _data = new Uint8Array(data);

            return crypto.subtle.decrypt(cryptoConfigGCM(_data.subarray(0, 12)), com, _data.subarray(12));
        }

        async function cryptoSign(sec, data){
            const _sec = await crypto.subtle.importKey("pkcs8", sec, cryptoConfigECDSA(), false, ["sign"]);

            return crypto.subtle.sign(cryptoConfigDSA(), _sec, data);
        }

        async function cryptoVerify(pub, sign, data){
            const _pub = await crypto.subtle.importKey("spki", pub, cryptoConfigECDSA(), false, ["verify"]);

            return crypto.subtle.verify(cryptoConfigDSA(), _pub, sign, data);
        }

        function toHex(buffer){
            return [...new Uint8Array(buffer)].map(n => n.toString(16).toUpperCase().padStart(2, "0")).join("");
        }

        const sample = new TextEncoder().encode("hogehoge");

        const keyDerive1 = await cryptoExportDerive();
        const keyDerive2 = await cryptoExportDerive();
        const keySign = await cryptoExportSign();

        const keyCommon1P2S = await cryptoDerive(keyDerive1.pub, keyDerive2.sec);
        const keyCommon2P1S = await cryptoDerive(keyDerive2.pub, keyDerive1.sec);

        const encode = await cryptoEncrypt(keyCommon1P2S, sample);
        const decode = await cryptoDecrypt(keyCommon2P1S, encode);

        const sign = await cryptoSign(keySign.sec, sample);
        const verify = await cryptoVerify(keySign.pub, sign, decode);

        const hash1 = await cryptoDigest(sample);
        const hash2 = await cryptoDigest(decode);

        console.log("---------- Exported Derive Keys ----------");
        console.log(keyDerive1.pub);
        console.log(keyDerive1.sec);
        console.log(keyDerive2.pub);
        console.log(keyDerive2.sec);

        console.log("---------- Exported Sign Keys ----------");
        console.log(keySign.pub);
        console.log(keySign.sec);

        console.log("---------- Derived Common Keys ----------");
        console.log(keyCommon1P2S);
        console.log(keyCommon2P1S);

        console.log("---------- Sample Data ----------");
        console.log(new TextDecoder().decode(sample));

        console.log("---------- Encoded Data ----------");
        console.log(new TextDecoder().decode(encode));

        console.log("---------- Decoded Data ----------");
        console.log(new TextDecoder().decode(decode));

        console.log("---------- Data Signature ----------");
        console.log(sign);

        console.log("---------- Signature Verify Result ----------");
        console.log(verify);

        console.log("---------- Raw Hash ----------");
        console.log(toHex(hash1));

        console.log("---------- Decoded Hash ----------");
        console.log(toHex(hash2));
    </script>
</html>