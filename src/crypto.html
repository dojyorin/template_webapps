<!doctype html>
<html lang="ja">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, height=device-height, minimum-scale=1, maximum-scale=1, initial-scale=1, user-scalable=no">
        <meta name="referrer" content="no-referrer">

        <title></title>
    </head>

    <body></body>

    <script async type="module">
        function bufferJoin(...sources){
            const data = new Uint8Array(sources.reduce((a, {byteLength}) => a += byteLength, 0));

            let offset = 0;
            for(const source of sources){
                data.set(new Uint8Array(source?.buffer ?? source), offset);
                offset += source.byteLength;
            }

            return data.buffer;
        }

        function bufferEqual(source1, source2){
            const dv1 = new DataView(source1?.buffer ?? source1);
            const dv2 = new DataView(source2?.buffer ?? source2);

            if(dv1.byteLength !== dv2.byteLength){
                return false;
            }

            for(let i = 0; i < dv1.byteLength; i++){
                if(dv1.getUint8(i) !== dv2.getUint8(i)){
                    return false;
                }
            }

            return true;
        }

        function toHex(data){
            return Array.from(new Uint8Array(data?.buffer ?? data)).map(n => n.toString(16).padStart(2, "0").toUpperCase()).join("");
        }

        function wcConfigPBKDF2(v){
            return {
                name: "PBKDF2",
                hash: "SHA-512",
                iterations: 0xFFFF,
                salt: v
            };
        }

        function wcConfigECC(){
            return {
                name: "ECDH",
                namedCurve: "P-521"
            };
        }

        function wcConfigECDH(v){
            return {
                name: "ECDH",
                public: v
            };
        }

        function wcConfigAES(){
            return {
                name: "AES-GCM",
                length: 256
            };
        }

        function wcConfigGCM(v){
            return {
                name: "AES-GCM",
                tagLength: 128,
                iv: v
            };
        }

        async function wcHashDigest(data){
            return crypto.subtle.digest("SHA-512", data);
        }

        async function wcDerivePassword(pw, salt){
            return crypto.subtle.deriveKey(wcConfigPBKDF2(salt), await crypto.subtle.importKey("raw", new TextEncoder().encode(pw), "PBKDF2", false, ["deriveKey"]), wcConfigAES(), false, ["wrapKey", "unwrapKey"]);
        }

        async function wcExportKey(pw){
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const salt = crypto.getRandomValues(new Uint8Array(16));

            const {publicKey, privateKey} = await crypto.subtle.generateKey(wcConfigECC(), true, ["deriveKey"]);

            return {
                pub: await crypto.subtle.exportKey("spki", publicKey),
                sec: bufferJoin(iv, salt, await crypto.subtle.wrapKey("pkcs8", privateKey, await wcDerivePassword(pw, salt), wcConfigGCM(iv)))
            };
        }

        async function wcImportKey(pub, sec, pw){
            const vpub = new Uint8Array(pub?.buffer ?? pub);
            const vsec = new Uint8Array(sec?.buffer ?? sec);

            return {
                pub: await crypto.subtle.importKey("spki", vpub, wcConfigECC(), false, []),
                sec: await crypto.subtle.unwrapKey("pkcs8", vsec.subarray(28), await wcDerivePassword(pw, vsec.subarray(12, 28)), wcConfigGCM(vsec.subarray(0, 12)), wcConfigECC(), false, ["deriveKey"])
            };
        }

        async function wcDeriveKey(pub, sec){
            return crypto.subtle.deriveKey(wcConfigECDH(pub), sec, wcConfigAES(), false, ["encrypt", "decrypt"]);
        }

        async function wcEncryptData(com, data){
            const iv = crypto.getRandomValues(new Uint8Array(12));

            return bufferJoin(iv, await crypto.subtle.encrypt(wcConfigGCM(iv), com, data));
        }

        async function wcDecryptData(com, data){
            const vdata = new Uint8Array(data?.buffer ?? data);

            return crypto.subtle.decrypt(wcConfigGCM(vdata.subarray(0, 12)), com, vdata.subarray(12));
        }

        const raw = new TextEncoder().encode("hogehoge");

        const key1o = await wcExportKey("foobar");
        const key1i = await wcImportKey(key1o.pub, key1o.sec, "foobar");

        const key2o = await wcExportKey("foobar");
        const key2i = await wcImportKey(key2o.pub, key2o.sec, "foobar");

        const key1pub2sec = await wcDeriveKey(key1i.pub, key2i.sec);
        const key2pub1sec = await wcDeriveKey(key2i.pub, key1i.sec);

        const encode = await wcEncryptData(key1pub2sec, raw);
        const decode = await wcDecryptData(key2pub1sec, encode);

        console.log("---------- Exported Keys ----------");
        for(const key of [key1o.pub, key1o.sec, key2o.pub, key2o.sec]){
            console.log(key);
        }

        console.log("---------- Imported Keys ----------");
        for(const key of [key1i.pub, key1i.sec, key2i.pub, key2i.sec]){
            console.log(key);
        }

        console.log("---------- Derived Keys ----------");
        for(const key of [key1pub2sec, key2pub1sec]){
            console.log(key);
        }

        console.log("---------- Encoded Data ----------");
        console.log(new TextDecoder().decode(encode));

        console.log("---------- Raw Data ----------");
        console.log(new TextDecoder().decode(raw));

        console.log("---------- Decoded Data ----------");
        console.log(new TextDecoder().decode(decode));

        console.log("---------- Raw Hash ----------");
        console.log(toHex(await wcHashDigest(raw)));

        console.log("---------- Decoded Hash ----------");
        console.log(toHex(await wcHashDigest(decode)));

        console.log("---------- Compare Hash ----------");
        console.log(bufferEqual(raw, decode));
    </script>
</html>