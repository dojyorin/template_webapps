<!doctype html>
<html lang="ja">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
        <meta name="referrer" content="no-referrer">

        <title>WebCrypto</title>
    </head>

    <body>
        Web Crypto API
    </body>

    <script async type="module">
        function concatBuffer(...arrays){
            return arrays.reduce((c, array)=>{
                c.byte.set(new Uint8Array(array?.buffer ?? array), c.offset);
                c.offset += array.byteLength;
                return c;
            }, {
                byte: new Uint8Array(arrays.reduce((c, {byteLength}) => c += byteLength, 0)),
                offset: 0
            }).byte.buffer;
        }

        function CONFIG_PBKDF2(v){
            return {
                name: "PBKDF2",
                hash: "SHA-512",
                iterations: 0xFFFF,
                salt: v
            };
        }

        function CONFIG_CURVE(){
            return {
                name: "ECDH",
                namedCurve: "P-521"
            };
        }

        function CONFIG_ECDH(v){
            return {
                name: "ECDH",
                public: v
            };
        }

        function CONFIG_AES(){
            return {
                name: "AES-GCM",
                length: 256
            };
        }

        function CONFIG_GCM(v){
            return {
                name: "AES-GCM",
                tagLength: 128,
                iv: v
            };
        }

        async function derivePassword(password, salt){
            return crypto.subtle.deriveKey(CONFIG_PBKDF2(salt), await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveKey"]), CONFIG_AES(), false, ["wrapKey", "unwrapKey"]);
        }

        function hashDigest(data){
            return crypto.subtle.digest("SHA-512", data);
        }

        function generateKey(){
            return crypto.subtle.generateKey(CONFIG_CURVE(), true, ["deriveKey"]);
        }

        async function importKey(key, password){
            return key.byteLength === 158 ? crypto.subtle.importKey("spki", key, CONFIG_CURVE(), false, []) : crypto.subtle.unwrapKey("pkcs8", key.slice(28), await derivePassword(password, key.slice(0, 16)), CONFIG_GCM(key.slice(16, 28)), CONFIG_CURVE(), false, ["deriveKey"]);
        }

        async function exportKey(key, password){
            const salt = crypto.getRandomValues(new Uint8Array(16));
            const iv = crypto.getRandomValues(new Uint8Array(12));

            return key.type === "public" ? crypto.subtle.exportKey("spki", key) : concatBuffer(salt, iv, await crypto.subtle.wrapKey("pkcs8", key, await derivePassword(password, salt), CONFIG_GCM(iv)));
        }

        function deriveKey(keypublic, keyprivate){
            return crypto.subtle.deriveKey(CONFIG_ECDH(keypublic), keyprivate, CONFIG_AES(), false, ["encrypt", "decrypt"]);
        }

        async function encryptData(key, data){
            const iv = crypto.getRandomValues(new Uint8Array(12));

            return concatBuffer(iv, await crypto.subtle.encrypt(CONFIG_GCM(iv), key, data));
        }

        function decryptData(key, data){
            return crypto.subtle.decrypt(CONFIG_GCM(data.slice(0, 12)), key, data.slice(12));
        }

        const key1 = await generateKey();
        const key2 = await generateKey();

        const key1ExportPublic = await exportKey(key1.publicKey);
        const key1ExportPrivate = await exportKey(key1.privateKey, "foobar");
        const key2ExportPublic = await exportKey(key2.publicKey);
        const key2ExportPrivate = await exportKey(key2.privateKey, "foobar");

        console.log("---------- Exported Keys ----------");
        for(const key of [key1ExportPublic, key1ExportPrivate, key2ExportPublic, key2ExportPrivate]){
            console.log(key);
        }

        const key1ImportPublic = await importKey(key1ExportPublic);
        const key1ImportPrivate = await importKey(key1ExportPrivate, "foobar");
        const key2ImportPublic = await importKey(key2ExportPublic);
        const key2ImportPrivate = await importKey(key2ExportPrivate, "foobar");

        console.log("---------- Imported Keys ----------");
        for(const key of [key1ImportPublic, key1ImportPrivate, key2ImportPublic, key2ImportPrivate]){
            console.log(key);
        }

        const keyDerivePublic1Private2 = await deriveKey(key1ImportPublic, key2ImportPrivate);
        const keyDerivePublic2Private1 = await deriveKey(key2ImportPublic, key1ImportPrivate);

        console.log("---------- Derived Keys ----------");
        for(const key of [keyDerivePublic1Private2, keyDerivePublic2Private1]){
            console.log(key);
        }

        const raw = new TextEncoder().encode("hogehoge");

        console.log("---------- Raw Data ----------");
        console.log(new TextDecoder().decode(raw));

        console.log("---------- Raw Hash ----------");
        console.log(Array.from(new Uint8Array(await hashDigest(raw))).map(n => n.toString(16)).join(""));

        const encode = await encryptData(keyDerivePublic1Private2, raw);
        const decode = await decryptData(keyDerivePublic2Private1, encode);

        console.log("---------- Encoded Data ----------");
        console.log(new TextDecoder().decode(encode));

        console.log("---------- Decoded Data ----------");
        console.log(new TextDecoder().decode(decode));

        console.log("---------- Decoded Hash ----------");
        console.log(Array.from(new Uint8Array(await hashDigest(decode))).map(n => n.toString(16)).join(""));
    </script>
</html>