<!doctype html>
<html lang="ja">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
        <meta name="referrer" content="no-referrer">

        <title>WebCrypto</title>
    </head>

    <body>
        Web Crypto API
    </body>

    <script async type="module">
        function concatBuffer(...arrays){
            return arrays.reduce((c, array)=>{
                c.byte.set(new Uint8Array(array?.buffer ?? array), c.offset);
                c.offset += array.byteLength;
                return c;
            }, {
                byte: new Uint8Array(arrays.reduce((c, {byteLength}) => c += byteLength, 0)),
                offset: 0
            }).byte.buffer;
        }

        function CONFIG_PBKDF2(v){
            return {
                name: "PBKDF2",
                hash: "SHA-512",
                iterations: 0xFFFF,
                salt: v
            };
        }

        function CONFIG_CURVE(){
            return {
                name: "ECDH",
                namedCurve: "P-521"
            };
        }

        function CONFIG_ECDH(v){
            return {
                name: "ECDH",
                public: v
            };
        }

        function CONFIG_AES(){
            return {
                name: "AES-GCM",
                length: 256
            };
        }

        function CONFIG_GCM(v){
            return {
                name: "AES-GCM",
                tagLength: 128,
                iv: v
            };
        }

        async function createPassword(pw, salt){
            return crypto.subtle.deriveKey(CONFIG_PBKDF2(salt), await crypto.subtle.importKey("raw", new TextEncoder().encode(pw), "PBKDF2", false, ["deriveKey"]), CONFIG_AES(), false, ["wrapKey", "unwrapKey"]);
        }

        function hashDigest(data){
            return crypto.subtle.digest("SHA-512", data);
        }

        async function exportKey(pw){
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const salt = crypto.getRandomValues(new Uint8Array(16));

            const {publicKey, privateKey} = await crypto.subtle.generateKey(CONFIG_CURVE(), true, ["deriveKey"]);

            return {
                pub: await crypto.subtle.exportKey("spki", publicKey),
                sec: concatBuffer(iv, salt, await crypto.subtle.wrapKey("pkcs8", privateKey, await createPassword(pw, salt), CONFIG_GCM(iv)))
            };
        }

        async function importKey(pub, sec, pw){
            return {
                pub: await crypto.subtle.importKey("spki", pub, CONFIG_CURVE(), false, []),
                sec: await crypto.subtle.unwrapKey("pkcs8", sec.slice(28), await createPassword(pw, sec.slice(12, 28)), CONFIG_GCM(sec.slice(0, 12)), CONFIG_CURVE(), false, ["deriveKey"])
            };
        }

        function deriveKey(pub, sec){
            return crypto.subtle.deriveKey(CONFIG_ECDH(pub), sec, CONFIG_AES(), false, ["encrypt", "decrypt"]);
        }

        async function encryptData(com, data){
            const iv = crypto.getRandomValues(new Uint8Array(12));

            return concatBuffer(iv, await crypto.subtle.encrypt(CONFIG_GCM(iv), com, data));
        }

        function decryptData(com, data){
            return crypto.subtle.decrypt(CONFIG_GCM(data.slice(0, 12)), com, data.slice(12));
        }

        const raw = new TextEncoder().encode("hogehoge");

        const key1o = await exportKey("foobar");
        const key1i = await importKey(key1o.pub, key1o.sec, "foobar");

        const key2o = await exportKey("foobar");
        const key2i = await importKey(key2o.pub, key2o.sec, "foobar");

        const key1pub2sec = await deriveKey(key1i.pub, key2i.sec);
        const key2pub1sec = await deriveKey(key2i.pub, key1i.sec);

        const encode = await encryptData(key1pub2sec, raw);
        const decode = await decryptData(key2pub1sec, encode);

        console.log("---------- Exported Keys ----------");
        for(const key of [key1o.pub, key1o.sec, key2o.pub, key2o.sec]){
            console.log(key);
        }

        console.log("---------- Imported Keys ----------");
        for(const key of [key1i.pub, key1i.sec, key2i.pub, key2i.sec]){
            console.log(key);
        }

        console.log("---------- Derived Keys ----------");
        for(const key of [key1pub2sec, key2pub1sec]){
            console.log(key);
        }

        console.log("---------- Raw Data ----------");
        console.log(new TextDecoder().decode(raw));

        console.log("---------- Raw Hash ----------");
        console.log(Array.from(new Uint8Array(await hashDigest(raw))).map(n => n.toString(16)).join(""));

        console.log("---------- Encoded Data ----------");
        console.log(new TextDecoder().decode(encode));

        console.log("---------- Decoded Data ----------");
        console.log(new TextDecoder().decode(decode));

        console.log("---------- Decoded Hash ----------");
        console.log(Array.from(new Uint8Array(await hashDigest(decode))).map(n => n.toString(16)).join(""));
    </script>
</html>