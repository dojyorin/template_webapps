<!doctype html>
<html lang="ja">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, height=device-height, minimum-scale=1, maximum-scale=1, initial-scale=1, user-scalable=no">
        <meta name="referrer" content="no-referrer">

        <title>WebCrypto</title>
    </head>

    <body>
        Web Crypto API
    </body>

    <script async type="module">
        function concatBufferSource(...sources){
            return sources.reduce((sum, source)=>{
                sum.byte.set(new Uint8Array(source?.buffer ?? source), sum.offset);
                sum.offset += source.byteLength;
                return sum;
            }, {
                byte: new Uint8Array(sources.reduce((sum, {byteLength}) => sum += byteLength, 0)),
                offset: 0
            }).byte.buffer;
        }

        function CONFIG_PBKDF2(v){
            return {
                name: "PBKDF2",
                hash: "SHA-512",
                iterations: 0xFFFF,
                salt: v
            };
        }

        function CONFIG_CURVE(){
            return {
                name: "ECDH",
                namedCurve: "P-521"
            };
        }

        function CONFIG_ECDH(v){
            return {
                name: "ECDH",
                public: v
            };
        }

        function CONFIG_AES(){
            return {
                name: "AES-GCM",
                length: 256
            };
        }

        function CONFIG_GCM(v){
            return {
                name: "AES-GCM",
                tagLength: 128,
                iv: v
            };
        }

        async function derivePassword(pw, salt){
            return crypto.subtle.deriveKey(CONFIG_PBKDF2(salt), await crypto.subtle.importKey("raw", new TextEncoder().encode(pw), "PBKDF2", false, ["deriveKey"]), CONFIG_AES(), false, ["wrapKey", "unwrapKey"]);
        }

        async function hashDigest(data){
            return crypto.subtle.digest("SHA-512", data);
        }

        async function exportKey(pw){
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const salt = crypto.getRandomValues(new Uint8Array(16));

            const {publicKey, privateKey} = await crypto.subtle.generateKey(CONFIG_CURVE(), true, ["deriveKey"]);

            return {
                pub: await crypto.subtle.exportKey("spki", publicKey),
                sec: concatBufferSource(iv, salt, await crypto.subtle.wrapKey("pkcs8", privateKey, await derivePassword(pw, salt), CONFIG_GCM(iv)))
            };
        }

        async function importKey(pub, sec, pw){
            const vpub = new Uint8Array(pub?.buffer ?? pub);
            const vsec = new Uint8Array(sec?.buffer ?? sec);

            return {
                pub: await crypto.subtle.importKey("spki", vpub, CONFIG_CURVE(), false, []),
                sec: await crypto.subtle.unwrapKey("pkcs8", vsec.subarray(28), await derivePassword(pw, vsec.subarray(12, 28)), CONFIG_GCM(vsec.subarray(0, 12)), CONFIG_CURVE(), false, ["deriveKey"])
            };
        }

        async function deriveKey(pub, sec){
            return crypto.subtle.deriveKey(CONFIG_ECDH(pub), sec, CONFIG_AES(), false, ["encrypt", "decrypt"]);
        }

        async function encryptData(com, data){
            const iv = crypto.getRandomValues(new Uint8Array(12));

            return concatBufferSource(iv, await crypto.subtle.encrypt(CONFIG_GCM(iv), com, data));
        }

        async function decryptData(com, data){
            const vdata = new Uint8Array(data?.buffer ?? data);

            return crypto.subtle.decrypt(CONFIG_GCM(vdata.subarray(0, 12)), com, vdata.subarray(12));
        }

        async function toHex(buffer){
            return Array.from(new Uint8Array(await hashDigest(buffer))).map(n => n.toString(16)).join("");
        }

        const raw = new TextEncoder().encode("hogehoge");

        const key1o = await exportKey("foobar");
        const key1i = await importKey(key1o.pub, key1o.sec, "foobar");

        const key2o = await exportKey("foobar");
        const key2i = await importKey(key2o.pub, key2o.sec, "foobar");

        const key1pub2sec = await deriveKey(key1i.pub, key2i.sec);
        const key2pub1sec = await deriveKey(key2i.pub, key1i.sec);

        const encode = await encryptData(key1pub2sec, raw);
        const decode = await decryptData(key2pub1sec, encode);

        console.log("---------- Exported Keys ----------");
        for(const key of [key1o.pub, key1o.sec, key2o.pub, key2o.sec]){
            console.log(key);
        }

        console.log("---------- Imported Keys ----------");
        for(const key of [key1i.pub, key1i.sec, key2i.pub, key2i.sec]){
            console.log(key);
        }

        console.log("---------- Derived Keys ----------");
        for(const key of [key1pub2sec, key2pub1sec]){
            console.log(key);
        }

        console.log("---------- Encoded Data ----------");
        console.log(new TextDecoder().decode(encode));

        console.log("---------- Raw Data ----------");
        console.log(new TextDecoder().decode(raw));

        console.log("---------- Decoded Data ----------");
        console.log(new TextDecoder().decode(decode));

        console.log("---------- Raw Hash ----------");
        console.log(await toHex(raw));

        console.log("---------- Decoded Hash ----------");
        console.log(await toHex(decode));
    </script>
</html>