<!doctype html>
<meta charset="utf-8">

<script async type="module">
    /**
     * @param {Uint8Array<ArrayBuffer>} data
     * @return {Promise<Uint8Array<ArrayBuffer>>}
     */
    async function digest(data) {
        return new Uint8Array(await crypto.subtle.digest("SHA-256", data));
    }

    /**
     * @return {Promise<Record<keyof CryptoKeyPair, Uint8Array<ArrayBuffer>>>}
     */
    async function generateKeyX25519() {
        /** @satisfies {CryptoKeyPair} */
        const {publicKey, privateKey} = await crypto.subtle.generateKey("X25519", true, ["deriveKey"]);

        return {
            publicKey: new Uint8Array(await crypto.subtle.exportKey("spki", publicKey)),
            privateKey: new Uint8Array(await crypto.subtle.exportKey("pkcs8", privateKey))
        };
    }

    /**
     * @return {Promise<Record<keyof CryptoKeyPair, Uint8Array<ArrayBuffer>>>}
     */
    async function generateKeyEd25519() {
        /** @satisfies {CryptoKeyPair} */
        const {publicKey, privateKey} = await crypto.subtle.generateKey("Ed25519", true, ["sign"]);

        return {
            publicKey: new Uint8Array(await crypto.subtle.exportKey("spki", publicKey)),
            privateKey: new Uint8Array(await crypto.subtle.exportKey("pkcs8", privateKey))
        };
    }

    /**
     * @param {string} password
     * @param {Uint8Array<ArrayBuffer>} data
     * @return {Promise<Uint8Array<ArrayBuffer>>}
     */
    async function encryptPassword(password, data) {
        const MAC_SIZE = 16;

        const salt = crypto.getRandomValues(new Uint8Array(16));
        const iv = crypto.getRandomValues(new Uint8Array(12));

        const material = await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveKey"]);

        const key = await crypto.subtle.deriveKey({
            name: material.algorithm.name,
            hash: "SHA-256",
            iterations: 1000000,
            salt: salt
        }, material, {
            name: "AES-GCM",
            length: 128
        }, false, ["encrypt"]);

        const output = await crypto.subtle.encrypt({
            name: key.algorithm.name,
            iv: iv
        }, key, data);

        const compose = new Uint8Array(salt.byteLength + iv.byteLength + MAC_SIZE + data.byteLength);
        compose.set(salt, 0);
        compose.set(iv, salt.byteLength);
        compose.set(new Uint8Array(output), salt.byteLength + iv.byteLength);

        return compose;
    }

    /**
     * @param {Uint8Array<ArrayBuffer>} hash
     * @param {Uint8Array<ArrayBuffer>} data
     * @return {Promise<Uint8Array<ArrayBuffer>>}
     */
    async function encryptHash(hash, data) {
        const MAC_SIZE = 16;

        const salt = crypto.getRandomValues(new Uint8Array(hash.byteLength));
        const iv = crypto.getRandomValues(new Uint8Array(12));

        const material = await crypto.subtle.importKey("raw", hash, "HKDF", false, ["deriveKey"]);

        const key = await crypto.subtle.deriveKey({
            name: material.algorithm.name,
            hash: "SHA-256",
            info: new Uint8Array(0),
            salt: salt
        }, material, {
            name: "AES-GCM",
            length: 128
        }, false, ["encrypt"]);

        const output = await crypto.subtle.encrypt({
            name: key.algorithm.name,
            iv: iv
        }, key, data);

        const compose = new Uint8Array(salt.byteLength + iv.byteLength + MAC_SIZE + data.byteLength);
        compose.set(salt, 0);
        compose.set(iv, salt.byteLength);
        compose.set(new Uint8Array(output), salt.byteLength + iv.byteLength);

        return compose;
    }

    /**
     * @param {Uint8Array<ArrayBuffer>} privateKey
     * @param {Uint8Array<ArrayBuffer>} publicKey
     * @param {Uint8Array<ArrayBuffer>} data
     * @return {Promise<Uint8Array<ArrayBuffer>>}
     */
    async function encryptX25519(privateKey, publicKey, data) {
        const MAC_SIZE = 16;

        const iv = crypto.getRandomValues(new Uint8Array(12));

        const material = await crypto.subtle.importKey("pkcs8", privateKey, "X25519", false, ["deriveKey"]);

        const key = await crypto.subtle.deriveKey({
            name: material.algorithm.name,
            public: await crypto.subtle.importKey("spki", publicKey, material.algorithm.name, false, [])
        }, material, {
            name: "AES-GCM",
            length: 128
        }, false, ["encrypt"]);

        const output = await crypto.subtle.encrypt({
            name: key.algorithm.name,
            iv: iv
        }, key, data);

        const compose = new Uint8Array(iv.byteLength + MAC_SIZE + data.byteLength);
        compose.set(iv, 0);
        compose.set(new Uint8Array(output), iv.byteLength);

        return compose;
    }

    /**
     * @param {string} password
     * @param {Uint8Array<ArrayBuffer>} data
     * @return {Promise<Uint8Array<ArrayBuffer>>}
     */
    async function decryptPassword(password, data) {
        const salt = data.subarray(0, 16);
        const iv = data.subarray(salt.byteLength, salt.byteLength + 12);

        const material = await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveKey"]);

        const key = await crypto.subtle.deriveKey({
            name: material.algorithm.name,
            hash: "SHA-256",
            iterations: 1000000,
            salt: salt
        }, material, {
            name: "AES-GCM",
            length: 128
        }, false, ["decrypt"]);

        const output = await crypto.subtle.decrypt({
            name: key.algorithm.name,
            iv: iv
        }, key, data.subarray(salt.byteLength + iv.byteLength));

        return new Uint8Array(output);
    }

    /**
     * @param {Uint8Array<ArrayBuffer>} hash
     * @param {Uint8Array<ArrayBuffer>} data
     * @return {Promise<Uint8Array<ArrayBuffer>>}
     */
    async function decryptHash(hash, data) {
        const salt = data.subarray(0, hash.byteLength);
        const iv = data.subarray(salt.byteLength, salt.byteLength + 12);

        const material = await crypto.subtle.importKey("raw", hash, "HKDF", false, ["deriveKey"]);

        const key = await crypto.subtle.deriveKey({
            name: material.algorithm.name,
            hash: "SHA-256",
            info: new Uint8Array(0),
            salt: salt
        }, material, {
            name: "AES-GCM",
            length: 128
        }, false, ["decrypt"]);

        const output = await crypto.subtle.decrypt({
            name: key.algorithm.name,
            iv: iv
        }, key, data.subarray(salt.byteLength + iv.byteLength));

        return new Uint8Array(output);
    }

    /**
     * @param {Uint8Array<ArrayBuffer>} privateKey
     * @param {Uint8Array<ArrayBuffer>} publicKey
     * @param {Uint8Array<ArrayBuffer>} data
     * @return {Promise<Uint8Array<ArrayBuffer>>}
     */
    async function decryptX25519(privateKey, publicKey, data) {
        const iv = data.subarray(0, 12);

        const material = await crypto.subtle.importKey("pkcs8", privateKey, "X25519", false, ["deriveKey"]);

        const key = await crypto.subtle.deriveKey({
            name: material.algorithm.name,
            public: await crypto.subtle.importKey("spki", publicKey, material.algorithm.name, false, [])
        }, material, {
            name: "AES-GCM",
            length: 128
        }, false, ["decrypt"]);

        const output = await crypto.subtle.decrypt({
            name: key.algorithm.name,
            iv: iv
        }, key, data.subarray(iv.byteLength));

        return new Uint8Array(output);
    }

    /**
     * @param {Uint8Array<ArrayBuffer>} privateKey
     * @param {Uint8Array<ArrayBuffer>} data
     * @return {Promise<Uint8Array<ArrayBuffer>>}
     */
    async function signEd25519(privateKey, data) {
        const key = await crypto.subtle.importKey("pkcs8", privateKey, "Ed25519", false, ["sign"]);
        const output = await crypto.subtle.sign(key.algorithm.name, key, data);

        return new Uint8Array(output);
    }

    /**
     * @param {Uint8Array<ArrayBuffer>} publicKey
     * @param {Uint8Array<ArrayBuffer>} sign
     * @param {Uint8Array<ArrayBuffer>} data
     * @return {Promise<boolean>}
     */
    async function verifyEd25519(publicKey, sign, data) {
        const key = await crypto.subtle.importKey("spki", publicKey, "Ed25519", false, ["verify"]);
        const output = await crypto.subtle.verify(key.algorithm.name, key, sign, data);

        return output;
    }

    /**
     * @param {Uppercase<string>} name
     * @param {Uint8Array<ArrayBuffer>} data
     * @return {string}
     */
    function enpem(name, data) {
        return `-----BEGIN ${name}-----\n${data.toBase64()}\n-----END ${name}-----`;
    }

    /**
     * @param {string} data
     * @return {Uint8Array<ArrayBuffer>}
     */
    function depem(data) {
        return Uint8Array.fromBase64(data.trim().replaceAll("\r", "").split("\n").slice(1, -1).join(""));
    }

    /**
     * @param {number} size
     * @return {Uint8Array<ArrayBuffer>}
     */
    function _dummy(size) {
        return new Uint8Array(new Float32Array(size / 4).map(() => Math.random()).buffer);
    }

    const binary = _dummy(1024 ** 2);
    const password = "foobar";
    const passkey = _dummy(32);

    const hash = await digest(binary);
    const encryptKey = await generateKeyX25519();
    const signKey = await generateKeyEd25519();
    const encryptPasswordResult = await encryptPassword(password, binary);
    const encryptHashResult = await encryptHash(passkey, binary);
    const encryptX25519Result = await encryptX25519(encryptKey.privateKey, encryptKey.publicKey, binary);
    const decryptPasswordResult = await decryptPassword(password, encryptPasswordResult);
    const decryptHashResult = await decryptHash(passkey, encryptHashResult);
    const decryptX25519Result = await decryptX25519(encryptKey.privateKey, encryptKey.publicKey, encryptX25519Result);
    const signEd25519Result = await signEd25519(signKey.privateKey, binary);
    const verifyEd25519Result = await verifyEd25519(signKey.publicKey, signEd25519Result, binary);
    const enpemPrivateKey = enpem("PRIVATE KEY", encryptKey.privateKey);
    const enpemPublicKey = enpem("PUBLIC KEY", encryptKey.publicKey);
    const depemPrivateKey = depem(enpemPrivateKey);
    const depemPublicKey = depem(enpemPublicKey);

    console.log(hash);
    console.log(encryptKey);
    console.log(signKey);
    console.log(encryptPasswordResult);
    console.log(encryptHashResult);
    console.log(encryptX25519Result);
    console.log(decryptPasswordResult);
    console.log(decryptHashResult);
    console.log(decryptX25519Result);
    console.log(signEd25519Result);
    console.log(verifyEd25519Result);
    console.log(enpemPrivateKey);
    console.log(enpemPublicKey);
    console.log(depemPrivateKey);
    console.log(depemPublicKey);
</script>