<!doctype html>
<meta charset="utf-8">

<script async type="module">
    /**
    * @typedef {object} DataEntry
    * @prop {string} name
    * @prop {Uint8Array} body
    */

    /**
    * @param {DataEntry[]} files
    * @return {Uint8Array}
    */
    function minipackEncode(files) {
        const enc = new TextEncoder();

        const archive = new Uint8Array(files.reduce((size, {name, body}) => size + Uint32Array.BYTES_PER_ELEMENT * 2 + enc.encode(name).byteLength + body.byteLength, 0));

        for(let i = 0, j = 0; i < archive.byteLength; j++) {
            const {name, body} = files[j];
            const uname = enc.encode(name);

            new DataView(archive.buffer, i).setUint32(0, uname.byteLength);
            i += Uint32Array.BYTES_PER_ELEMENT;

            new DataView(archive.buffer, i).setUint32(0, body.byteLength);
            i += Uint32Array.BYTES_PER_ELEMENT;

            archive.set(uname, i);
            i += uname.byteLength;

            archive.set(body, i);
            i += body.byteLength;
        }

        return archive;
    }

    /**
    * @param {Uint8Array} archive
    * @return {DataEntry[]}
    */
    function minipackDecode(archive) {
        const dec = new TextDecoder();

        /** @type {DataEntry[]} */
        const files = [];

        for(let i = 0; i < archive.byteLength;) {
            const nsize = new DataView(archive.buffer, i).getUint32(0);
            i += Uint32Array.BYTES_PER_ELEMENT;

            const bsize = new DataView(archive.buffer, i).getUint32(0);
            i += Uint32Array.BYTES_PER_ELEMENT;

            files.push({
                name: dec.decode(archive.subarray(i, i += nsize)),
                body: archive.slice(i, i += bsize)
            });
        }

        return files;
    }
</script>