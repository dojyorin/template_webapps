<!doctype html>
<meta charset="utf-8">

<script async type="module">
    /**
     * @param {string} [name]
     * @param {number} [version]
     * @return {Promise<{get<T>(key: IDBValidKey): Promise<T>; set(key: IDBValidKey, value: unknown): Promise<void>; remove(key: IDBValidKey): Promise<void>; clear(): Promise<void>;}>}
     */
    async function openIDB(name, version) {
        const STORE_NAME = "main";

        /**
         * @template T
         * @param {IDBTransactionMode} mode
         * @param {(store: IDBObjectStore) => IDBRequest[] | void} getRequest
         * @return {Promise<T[]>}
         */
        async function createTransaction(mode, getRequest) {
            return await new Promise((res, rej) => {
                const transaction = db.transaction(STORE_NAME, mode);

                transaction.oncomplete = () => res(Promise.all(pendingResponses));
                transaction.onerror = () => rej(transaction.error);
                transaction.onabort = () => rej(transaction.error);

                const store = transaction.objectStore(STORE_NAME);
                const pendingResponses = Array.from(getRequest(store) ?? [], async (request) => {
                    return await new Promise((res, rej) => {
                        request.onsuccess = () => res(request.result);
                        request.onerror = () => rej(request.error);
                    });
                });
            });
        }

        /** @type {IDBDatabase} */
        const db = await new Promise((res, rej) => {
            const request = indexedDB.open(name ?? "kv", version ?? 1);

            request.onupgradeneeded = () => request.result.createObjectStore(STORE_NAME);
            request.onsuccess = () => res(request.result);
            request.onerror = () => rej(request.error);
            request.onblocked = () => rej(request.error);
        });

        return {
            async get(key) {
                const [value] = await createTransaction("readonly", (store) => {
                    return [store.get(key)];
                });

                return value;
            },
            async set(key, value) {
                await createTransaction("readwrite", (store) => {
                    store.put(value, key);
                });
            },
            async remove(key) {
                await createTransaction("readwrite", (store) => {
                    store.delete(key);
                });
            },
            async clear() {
                await createTransaction("readwrite", (store) => {
                    store.clear();
                });
            }
        };
    }
</script>