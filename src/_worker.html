<!doctype html>
<meta charset="utf-8">

<script async type="module">
    /**
     * @template T
     * @typedef {{id: string; body: T;}} WorkerMessageInternal
     */

    /**
     * @template T
     * @typedef {{message: T; transferables?: Transferable[];}} WorkerMessage
     */

    /**
     * @template T
     * @template U
     * @typedef {{get rawWorkers(): Worker[]; close(): void; submit(data?: WorkerMessage<T>): Promise<U>;}} WorkerThread
     */

    /**
     * @template T
     * @template U
     * @param {(message: T, event: MessageEvent<WorkerMessageInternal<T>>) => WorkerMessage<U> | void | Promise<WorkerMessage<U> | void>} func
     * @return {void}
     */
    function onWorkerThreadSubmit(func) {
        globalThis.addEventListener("message", async (/** @type {MessageEvent<WorkerMessageInternal<T>>} */ event) => {
            if (globalThis.name.startsWith("WorkerThread;")) {
                try {
                    const data = await func(event.data.body, event);

                    globalThis.postMessage(/** @satisfies {WorkerMessageInternal<U | void>} */ {
                        id: event.data.id,
                        body: data?.message
                    }, {
                        transfer: data?.transferables
                    });
                } catch (error) {
                    throw `${error};${event.data.id};`;
                }
            }
        });
    }

    /**
     * @template T
     * @template U
     * @param {string | URL} script
     * @param {number} [count]
     * @param {Omit<WorkerOptions, "type" | "name">} [option]
     * @return {WorkerThread<T, U>}
     */
    function createWorkerThread(script, count, option) {
        /**
         * @typedef {{data?: WorkerMessage<T>; res(value: U): void; rej(reason?: unknown): void;}} WorkerJob
         */

        /**
         * @param {Worker} worker
         * @param {WorkerJob} job
         * @return {void}
         */
        function runJob(worker, job) {
            /**
             * @param {MessageEvent<WorkerMessageInternal<U>>} event
             * @return {void}
             */
            function onMessage(event) {
                if (event.data.id === id) {
                    job.res(event.data.body);
                    releaseWorker();
                }
            }

            /**
             * @param {ErrorEvent} event
             * @return {void}
             */
            function onError(event) {
                if (event.message.endsWith(`;${id};`)) {
                    job.rej(event);
                    releaseWorker();
                }
            }

            function releaseWorker() {
                worker.removeEventListener("message", onMessage);
                worker.removeEventListener("error", onError);

                busy.delete(worker);

                const next = queue.shift();

                if (next) {
                    runJob(worker, next);
                }
            }

            busy.add(worker);

            /** @type {string} */
            const id = crypto.getRandomValues(new Uint8Array(32)).toHex();

            worker.addEventListener("message", onMessage);
            worker.addEventListener("error", onError);

            worker.postMessage(/** @satisfies {WorkerMessageInternal<T | void>} */ {
                id: id,
                body: job.data?.message
            }, {
                transfer: job.data?.transferables
            });
        }

        /** @type {Worker[]} */
        const pool = [];
        /** @type {WorkerJob[]} */
        const queue = [];
        /** @type {WeakSet<WeakKey>} */
        const busy = new WeakSet();

        for (let i = 0; i < (typeof count === "number" && count > 0 ? count : 1); i++) {
            const worker = new Worker(script, {
                type: "module",
                name: `WorkerThread;WorkerID=${i};`,
                ...option
            });

            pool.push(worker);
        }

        return {
            get rawWorkers() {
                return pool;
            },

            close() {
                for (const worker of pool) {
                    worker.terminate();
                }

                pool.splice(0);
                queue.splice(0);
            },

            async submit(data) {
                if (!pool.length) {
                    throw new ReferenceError("Worker is closed.");
                }

                return await new Promise((res, rej) => {
                    const worker = pool.find((v) => !busy.has(v));

                    if (worker) {
                        runJob(worker, {data, res, rej});
                    } else {
                        queue.push({data, res, rej});
                    }
                });
            }
        };
    }

    /**
     * @param {number} size
     * @return {Uint8Array}
     */
    function _dummy(size) {
        return new Uint8Array(new Float32Array(size / 4).map(() => Math.random()).buffer);
    }

    const js = /*js*/`
        ${onWorkerThreadSubmit}
        ${_dummy}

        onWorkerThreadSubmit((v) => {
            const binary = _dummy(v);

            return {
                message: binary,
                transferables: [binary.buffer]
            };
        });
    `;

    /** @type {WorkerThread<number, Uint8Array>} */
    const wt = createWorkerThread(`data:text/javascript;base64,${new TextEncoder().encode(js).toBase64()}`, navigator.hardwareConcurrency);

    const results = await Promise.all(Array.from({length: navigator.hardwareConcurrency * 2}, () => wt.submit({message: 1024 ** 2})));

    console.log(results);

    wt.close();
</script>