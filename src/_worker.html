<!doctype html>
<meta charset="utf-8">

<script async type="module">
    /**
     * @template T
     * @template U
     * @typedef {{open(): void; close(): void; submit(message: T, transfers?: Transferable[]): Promise<U>;}} WorkerEx
     */

    /**
     * @template T
     * @template U
     * @param {string | URL} script
     * @param {number} [parallel]
     * @return {WorkerEx<T, U>}
     */
    function createWorker(script, parallel) {
        /**
         * @param {Worker} worker
         * @param {typeof jobs[number]} job
         * @return {void}
         */
        function runWorker(worker, job) {
            function releaseWorker() {
                worker.onmessage = null;
                worker.onerror = null;

                busy.delete(worker);

                const next = jobs.shift();

                if (next) {
                    runWorker(worker, next);
                }
            }

            busy.add(worker);

            worker.onmessage = ({data}) => {
                releaseWorker();
                job.res(data);
            };

            worker.onerror = (event) => {
                releaseWorker();
                job.rej(event);
            };

            worker.postMessage(job.message, {
                transfer: job.transfers
            });
        }

        /** @type {WeakSet<Worker>} */
        const busy = new WeakSet();
        /** @type {Worker[]} */
        const workers = [];
        /** @type {{message: T; transfers?: Transferable[]; res(value: U): void; rej(reason?: unknown): void;}[]} */
        const jobs = [];

        return {
            open() {
                if (workers.length) {
                    throw new ReferenceError("Worker is already opened.");
                }

                for (let i = 0; i < (parallel ?? 1); i++) {
                    workers.push(
                        new Worker(script, {
                            type: "module"
                        })
                    );
                }
            },
            close() {
                for (const job of jobs) {
                    job.rej();
                }

                for (const worker of workers) {
                    worker.terminate();
                }

                workers.splice(0);
                jobs.splice(0);
            },
            async submit(message, transfers) {
                if (!workers.length) {
                    throw new ReferenceError("Worker is closed.");
                }

                return await new Promise((res, rej) => {
                    const worker = workers.find((v) => !busy.has(v));

                    if (worker) {
                        runWorker(worker, {message, transfers, res, rej});
                    } else {
                        jobs.push({message, transfers, res, rej});
                    }
                });
            }
        };
    }

    /**
     * @param {number} size
     * @return {Uint8Array<ArrayBuffer>}
     */
    function _dummy(size) {
        return new Uint8Array(new Float32Array(size / 4).map(() => Math.random()).buffer);
    }

    const js = /*js*/`
        ${_dummy}

        globalThis.onmessage = ({data}) => {
            const binary = _dummy(data);

            globalThis.postMessage(binary, {
                transfer: [binary.buffer]
            });
        };
    `;

    /** @type {WorkerEx<number, Uint8Array<ArrayBuffer>>} */
    const worker = createWorker(`data:text/javascript;base64,${new TextEncoder().encode(js).toBase64()}`, navigator.hardwareConcurrency);
    worker.open();

    const outputs = await Promise.all(Array.from({length: navigator.hardwareConcurrency * 2}, () => worker.submit(1024 ** 2)));

    console.log(outputs);

    worker.close();
</script>