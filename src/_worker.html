<!doctype html>
<meta charset="utf-8">

<script async type="module">
    /**
     * @template T
     * @typedef {{body: T; transferables?: Transferable[];}} WorkerMessage
     */

    /**
     * @template T
     * @template U
     * @param {(body: T) => WorkerMessage<U> | void | Promise<WorkerMessage<U> | void>} func
     * @return {void}
     */
    function onWorkerSubmit(func) {
        if (globalThis.name.startsWith("Worker#")) {
            globalThis.onmessage = async ({data}) => {
                const message = await func(data);

                globalThis.postMessage(message?.body, {
                    transfer: message?.transferables
                });
            };
        }
    }

    /**
     * @template T
     * @template U
     * @param {string | URL} script
     * @param {number} [count]
     * @return {{close(): void; submit(message?: WorkerMessage<T>): Promise<U>;}}
     */
    function createWorker(script, count) {
        /**
         * @param {Worker} worker
         * @param {typeof jobs[number]} job
         * @return {void}
         */
        function runJob(worker, job) {
            function releaseWorker() {
                worker.onmessage = null;
                worker.onerror = null;

                busy.delete(worker);

                const next = jobs.shift();

                if (next) {
                    runJob(worker, next);
                }
            }

            busy.add(worker);

            worker.onmessage = ({data}) => {
                releaseWorker();
                job.res(data);
            };

            worker.onerror = (event) => {
                releaseWorker();
                job.rej(event);
            };

            worker.postMessage(job.message?.body, {
                transfer: job.message?.transferables
            });
        }

        /** @type {WeakSet<WeakKey>} */
        const busy = new WeakSet();
        /** @type {Worker[]} */
        const workers = [];
        /** @type {{message?: WorkerMessage<T>; res(value: U): void; rej(reason?: unknown): void;}[]} */
        const jobs = [];

        for (let i = 0; i < (typeof count === "number" && count > 0 ? count : 1); i++) {
            workers.push(
                new Worker(script, {
                    type: "module",
                    name: `Worker#${i}`
                })
            );
        }

        return {
            close() {
                for (const worker of workers) {
                    worker.terminate();
                }

                workers.splice(0);
                jobs.splice(0);
            },
            async submit(message) {
                if (!workers.length) {
                    throw new ReferenceError("Worker is closed.");
                }

                return await new Promise((res, rej) => {
                    const worker = workers.find((v) => !busy.has(v));

                    if (worker) {
                        runJob(worker, {message, res, rej});
                    } else {
                        jobs.push({message, res, rej});
                    }
                });
            }
        };
    }

    /**
     * @param {number} size
     * @return {Uint8Array<ArrayBuffer>}
     */
    function _dummy(size) {
        return new Uint8Array(new Float32Array(size / 4).map(() => Math.random()).buffer);
    }

    const js = /*js*/`
        ${onWorkerSubmit}
        ${_dummy}

        onWorkerSubmit((v) => {
            const binary = _dummy(v);

            return {
                body: binary,
                transferables: [binary.buffer]
            };
        });
    `;

    const worker = createWorker(`data:text/javascript;base64,${new TextEncoder().encode(js).toBase64()}`, navigator.hardwareConcurrency);

    const results = await Promise.all(Array.from({length: navigator.hardwareConcurrency * 2}, () => worker.submit({body: 1024 ** 2})));

    console.log(results);

    worker.close();
</script>