<!doctype html>
<meta charset="utf-8">

<script async type="module">
    /**
     * @template T
     * @template U
     * @param {string | URL} script
     * @param {number} [count]
     * @return {{close(): void; submit(message: T, transfers?: Transferable[]): Promise<U>;}}
     */
    function createWorker(script, count) {
        /**
         * @param {Worker} worker
         * @param {typeof jobs[number]} job
         * @return {void}
         */
        function runJob(worker, job) {
            function releaseWorker() {
                worker.onmessage = null;
                worker.onerror = null;

                busy.delete(worker);

                const next = jobs.shift();

                if (next) {
                    runJob(worker, next);
                }
            }

            busy.add(worker);

            worker.onmessage = ({data}) => {
                releaseWorker();
                job.res(data);
            };

            worker.onerror = (event) => {
                releaseWorker();
                job.rej(event);
            };

            worker.postMessage(job.input.message, {
                transfer: job.input.transfers
            });
        }

        /** @type {WeakSet<WeakKey>} */
        const busy = new WeakSet();
        /** @type {Worker[]} */
        const workers = [];
        /** @type {{res(value: U): void; rej(reason?: unknown): void; input: {message: T; transfers?: Transferable[]};}[]} */
        const jobs = [];

        for (let i = 0; i < (typeof count === "number" && count > 0 ? count : 1); i++) {
            workers.push(
                new Worker(script, {
                    type: "module"
                })
            );
        }

        return {
            close() {
                for (const worker of workers) {
                    worker.terminate();
                }

                workers.splice(0);
                jobs.splice(0);
            },
            async submit(message, transfers) {
                if (!workers.length) {
                    throw new ReferenceError("Worker is closed.");
                }

                return await new Promise((res, rej) => {
                    /** @type {typeof jobs[number]} */
                    const job = {
                        res,
                        rej,
                        input: {
                            message,
                            transfers
                        }
                    };

                    const worker = workers.find((v) => !busy.has(v));

                    if (worker) {
                        runJob(worker, job);
                    } else {
                        jobs.push(job);
                    }
                });
            }
        };
    }

    /**
     * @param {number} size
     * @return {Uint8Array<ArrayBuffer>}
     */
    function _dummy(size) {
        return new Uint8Array(new Float32Array(size / 4).map(() => Math.random()).buffer);
    }

    const js = /*js*/`
        ${_dummy}

        globalThis.onmessage = ({data}) => {
            const binary = _dummy(data);

            globalThis.postMessage(binary, {
                transfer: [binary.buffer]
            });
        };
    `;

    const worker = createWorker(`data:text/javascript;base64,${new TextEncoder().encode(js).toBase64()}`, navigator.hardwareConcurrency);

    const results = await Promise.all(Array.from({length: navigator.hardwareConcurrency * 2}, () => worker.submit(1024 ** 2)));

    console.log(results);

    worker.close();
</script>